[
  {
    "id": "e46a2a52-5cc5-4614-9bf3-f8a7fbaebbfe",
    "name": "MedicalRecordAnalyzer",
    "record_type": "TOOL",
    "domain": "healthcare",
    "description": "A tool that analyzes medical records to extract key patient information, history, and clinical data",
    "code_snippet": "\nfrom typing import Dict, Any, List\nfrom pydantic import BaseModel, Field\nimport re\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\n\nclass MedicalRecordAnalyzerInput(BaseModel):\n    medical_record: str = Field(description=\"Medical record text to analyze\")\n\nclass MedicalRecordAnalyzer(Tool[MedicalRecordAnalyzerInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"A tool that analyzes medical records to extract key patient information and clinical data.\"\"\"\n    name = \"MedicalRecordAnalyzer\"\n    description = \"Analyzes medical records to extract structured patient information, vital signs, and clinical data\"\n    input_schema = MedicalRecordAnalyzerInput\n\n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"healthcare\", \"medical_record_analyzer\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: MedicalRecordAnalyzerInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        \"\"\"Analyze medical record to extract structured information.\"\"\"\n        record_text = input.medical_record\n        \n        # Extract patient information\n        patient_info = {}\n        name_match = re.search(r\"Name:\\s*([^\n]+)\", record_text)\n        if name_match:\n            patient_info[\"name\"] = name_match.group(1).strip()\n            \n        dob_match = re.search(r\"DOB:\\s*([^\n]+)\", record_text)\n        if dob_match:\n            patient_info[\"dob\"] = dob_match.group(1).strip()\n            \n        # Extract vital signs\n        vital_signs = {}\n        bp_match = re.search(r\"BP:\\s*([^\n]+)\", record_text)\n        if bp_match:\n            vital_signs[\"blood_pressure\"] = bp_match.group(1).strip()\n            \n        hr_match = re.search(r\"Heart Rate:\\s*([^\n]+)\", record_text)\n        if hr_match:\n            vital_signs[\"heart_rate\"] = hr_match.group(1).strip()\n            \n        temp_match = re.search(r\"Temperature:\\s*([^\n]+)\", record_text)\n        if temp_match:\n            vital_signs[\"temperature\"] = temp_match.group(1).strip()\n        \n        # Extract medications\n        medications = []\n        med_section = re.search(r\"CURRENT MEDICATIONS:(.*?)(?:\n\n|\n[A-Z]+)\", record_text, re.DOTALL)\n        if med_section:\n            med_text = med_section.group(1).strip()\n            med_lines = re.findall(r\"\\d+\\.\\s*([^\n]+)\", med_text)\n            for med in med_lines:\n                medications.append(med.strip())\n        \n        # Extract chief complaint\n        chief_complaint = \"\"\n        complaint_section = re.search(r\"CHIEF COMPLAINT:(.*?)(?:\n\n|\n[A-Z]+)\", record_text, re.DOTALL)\n        if complaint_section:\n            chief_complaint = complaint_section.group(1).strip()\n        \n        # Extract assessment and plan\n        assessment = \"\"\n        assessment_section = re.search(r\"ASSESSMENT:(.*?)(?:\n\n|\n[A-Z]+)\", record_text, re.DOTALL)\n        if assessment_section:\n            assessment = assessment_section.group(1).strip()\n            \n        plan = \"\"\n        plan_section = re.search(r\"PLAN:(.*?)(?:\n\n|$)\", record_text, re.DOTALL)\n        if plan_section:\n            plan = plan_section.group(1).strip()\n        \n        # Build response\n        result = {\n            \"patient_information\": patient_info,\n            \"vital_signs\": vital_signs,\n            \"current_medications\": medications,\n            \"chief_complaint\": chief_complaint,\n            \"assessment\": assessment,\n            \"plan\": plan\n        }\n        \n        import json\n        return StringToolOutput(json.dumps(result, indent=2))\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:30:51.649223",
    "last_updated": "2025-03-21T18:30:51.649254",
    "tags": [
      "medical",
      "healthcare",
      "record analysis"
    ],
    "metadata": {},
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "medical_record_analysis",
        "name": "Medical Record Analysis",
        "description": "Analyzes medical records to extract structured patient information and clinical data",
        "context": {
          "required_fields": [
            "medical_record_text"
          ],
          "produced_fields": [
            "patient_info",
            "vitals",
            "medications",
            "chief_complaint",
            "assessment",
            "plan"
          ]
        }
      }
    ]
  },
  {
    "id": "2ab69433-4fc5-40ad-80cf-1f48cbb0db3e",
    "name": "SymptomAnalyzer",
    "record_type": "AGENT",
    "domain": "healthcare",
    "description": "An agent that analyzes patient symptoms and provides possible conditions based on clinical data",
    "code_snippet": "\nfrom typing import List, Dict, Any, Optional\nimport re\n\nfrom beeai_framework.agents.react import ReActAgent\nfrom beeai_framework.agents.types import AgentMeta\nfrom beeai_framework.memory import TokenMemory\nfrom beeai_framework.backend.chat import ChatModel\nfrom beeai_framework.tools.tool import Tool\n\nclass SymptomAnalyzerInitializer:\n    \"\"\"\n    An agent that analyzes patient symptoms and provides possible conditions.\n    This agent can extract symptoms from medical records and suggest potential diagnoses.\n    \"\"\"\n    \n    @staticmethod\n    def create_agent(llm: ChatModel, tools: Optional[List[Tool]] = None) -> ReActAgent:\n        \"\"\"Create and configure the symptom analyzer agent.\"\"\"\n        # Use empty tools list if none provided\n        if tools is None:\n            tools = []\n            \n        # Define agent metadata\n        meta = AgentMeta(\n            name=\"SymptomAnalyzer\",\n            description=(\n                \"I am a symptom analysis agent that can extract symptoms from medical records, \"\n                \"categorize them by body system, and suggest possible diagnoses based on the \"\n                \"symptom pattern, vital signs, and patient history. \"\n                \"I always provide medical disclaimers and note when symptoms may have multiple \"\n                \"potential causes requiring further investigation.\"\n            ),\n            tools=tools\n        )\n        \n        # Create the agent\n        agent = ReActAgent(\n            llm=llm,\n            tools=tools,\n            memory=TokenMemory(llm),\n            meta=meta\n        )\n        \n        return agent\n        \n    @staticmethod\n    async def analyze_symptoms(structured_medical_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Analyze symptoms from structured medical data.\n        \n        Args:\n            structured_medical_data: Dictionary containing structured medical record information\n            \n        Returns:\n            Analysis of symptoms and possible conditions\n        \"\"\"\n        # Extract chief complaint\n        chief_complaint = structured_medical_data.get(\"chief_complaint\", \"\")\n        \n        # Extract symptoms from chief complaint\n        symptoms = []\n        if \"headache\" in chief_complaint.lower():\n            symptoms.append(\"headache\")\n        if \"dizziness\" in chief_complaint.lower():\n            symptoms.append(\"dizziness\")\n        if \"fatigue\" in chief_complaint.lower():\n            symptoms.append(\"fatigue\")\n            \n        # Get vital signs\n        vital_signs = structured_medical_data.get(\"vital_signs\", {})\n        \n        # Determine abnormal vitals\n        abnormal_vitals = []\n        bp = vital_signs.get(\"blood_pressure\", \"\")\n        if bp:\n            # Extract systolic and diastolic if available\n            bp_match = re.search(r\"(\\d+)/(\\d+)\", bp)\n            if bp_match:\n                systolic = int(bp_match.group(1))\n                diastolic = int(bp_match.group(2))\n                if systolic > 140 or diastolic > 90:\n                    abnormal_vitals.append(\"elevated blood pressure\")\n        \n        # Analyze current medications\n        medications = structured_medical_data.get(\"current_medications\", [])\n        \n        # Basic possible conditions based on symptoms and vitals\n        possible_conditions = []\n        if \"headache\" in symptoms:\n            possible_conditions.append({\n                \"condition\": \"Tension headache\",\n                \"confidence\": 0.7,\n                \"explanation\": \"Common with stress and prolonged screen time\"\n            })\n            possible_conditions.append({\n                \"condition\": \"Migraine\",\n                \"confidence\": 0.5,\n                \"explanation\": \"Especially if there's history of migraines\"\n            })\n            \n            if \"elevated blood pressure\" in abnormal_vitals:\n                possible_conditions.append({\n                    \"condition\": \"Hypertension-induced headache\",\n                    \"confidence\": 0.6,\n                    \"explanation\": \"Related to elevated blood pressure readings\"\n                })\n        \n        # Add medical disclaimer\n        disclaimer = (\n            \"MEDICAL DISCLAIMER: This analysis is for informational purposes only and does not \"\n            \"constitute medical advice. The possible conditions suggested are not definitive diagnoses. \"\n            \"Always consult with a qualified healthcare provider for proper diagnosis and treatment.\"\n        )\n        \n        return {\n            \"identified_symptoms\": symptoms,\n            \"abnormal_vitals\": abnormal_vitals,\n            \"current_medications\": medications,\n            \"possible_conditions\": possible_conditions,\n            \"disclaimer\": disclaimer\n        }\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:30:51.652952",
    "last_updated": "2025-03-21T18:30:51.652973",
    "tags": [
      "medical",
      "symptom",
      "diagnosis",
      "healthcare"
    ],
    "metadata": {},
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "symptom_analysis",
        "name": "Symptom Analysis",
        "description": "Analyzes symptoms from medical data and suggests possible conditions",
        "context": {
          "required_fields": [
            "patient_info",
            "vitals",
            "chief_complaint",
            "medical_history"
          ],
          "produced_fields": [
            "identified_symptoms",
            "possible_conditions",
            "analysis"
          ]
        }
      }
    ]
  },
  {
    "id": "7b3b1634-61dd-46a7-a54e-9665ce16d63f",
    "name": "MedicationInteractionChecker",
    "record_type": "TOOL",
    "domain": "healthcare",
    "description": "A tool that checks for potential interactions between medications",
    "code_snippet": "\nfrom typing import Dict, Any, List\nfrom pydantic import BaseModel, Field\n\nfrom beeai_framework.context import RunContext\nfrom beeai_framework.emitter.emitter import Emitter\nfrom beeai_framework.tools.tool import StringToolOutput, Tool, ToolRunOptions\n\nclass MedicationInteractionInput(BaseModel):\n    medications: List[str] = Field(description=\"List of medications to check for interactions\")\n    allergies: List[str] = Field(description=\"List of patient allergies\", default_factory=list)\n\nclass MedicationInteractionChecker(Tool[MedicationInteractionInput, ToolRunOptions, StringToolOutput]):\n    \"\"\"A tool that checks for potential interactions between medications.\"\"\"\n    name = \"MedicationInteractionChecker\"\n    description = \"Analyzes a list of medications to identify potential harmful interactions and contraindications\"\n    input_schema = MedicationInteractionInput\n\n    def _create_emitter(self) -> Emitter:\n        return Emitter.root().child(\n            namespace=[\"tool\", \"healthcare\", \"medication_checker\"],\n            creator=self,\n        )\n    \n    async def _run(self, input: MedicationInteractionInput, options: ToolRunOptions | None, context: RunContext) -> StringToolOutput:\n        \"\"\"Check for interactions between medications.\"\"\"\n        medications = input.medications\n        allergies = input.allergies\n        \n        # Simple interaction database (this would be more comprehensive in a real system)\n        known_interactions = {\n            (\"lisinopril\", \"spironolactone\"): \"Hyperkalemia risk (moderately severe)\",\n            (\"lisinopril\", \"naproxen\"): \"Reduced antihypertensive efficacy (moderate)\",\n            (\"levothyroxine\", \"calcium\"): \"Reduced levothyroxine absorption (moderate)\",\n            (\"ibuprofen\", \"aspirin\"): \"Increased bleeding risk (moderate)\",\n            (\"sumatriptan\", \"ibuprofen\"): \"No significant interaction (mild)\",\n        }\n        \n        # Check for drug class interactions\n        class_interactions = {\n            (\"ACE inhibitor\", \"NSAID\"): \"May reduce antihypertensive effect and increase kidney injury risk\",\n            (\"ACE inhibitor\", \"potassium-sparing diuretic\"): \"Increased hyperkalemia risk\",\n            (\"thyroid medication\", \"antacid\"): \"Decreased thyroid medication absorption\"\n        }\n        \n        # Simple drug classification\n        drug_classifications = {\n            \"lisinopril\": [\"ACE inhibitor\"],\n            \"enalapril\": [\"ACE inhibitor\"],\n            \"ibuprofen\": [\"NSAID\"],\n            \"naproxen\": [\"NSAID\"],\n            \"spironolactone\": [\"potassium-sparing diuretic\"],\n            \"levothyroxine\": [\"thyroid medication\"],\n            \"omeprazole\": [\"proton pump inhibitor\"],\n        }\n        \n        # Check for allergy contraindications\n        allergy_contraindications = []\n        for allergy in allergies:\n            allergy_lower = allergy.lower()\n            if allergy_lower == \"penicillin\":\n                penicillin_drugs = [\"amoxicillin\", \"ampicillin\", \"penicillin v\"]\n                for med in medications:\n                    if any(drug in med.lower() for drug in penicillin_drugs):\n                        allergy_contraindications.append(f\"{med} contraindicated due to penicillin allergy\")\n            elif allergy_lower == \"sulfa drugs\":\n                sulfa_drugs = [\"sulfamethoxazole\", \"sulfadiazine\", \"sulfasalazine\"]\n                for med in medications:\n                    if any(drug in med.lower() for drug in sulfa_drugs):\n                        allergy_contraindications.append(f\"{med} contraindicated due to sulfa allergy\")\n        \n        # Find direct interactions\n        direct_interactions = []\n        for i, med1 in enumerate(medications):\n            for med2 in medications[i+1:]:\n                # Normalize medication names\n                med1_lower = med1.lower().split()[0]  # Take first word, ignore dosage\n                med2_lower = med2.lower().split()[0]  # Take first word, ignore dosage\n                \n                # Check both orderings of the medications\n                interaction = known_interactions.get((med1_lower, med2_lower)) or known_interactions.get((med2_lower, med1_lower))\n                if interaction:\n                    direct_interactions.append({\n                        \"medications\": [med1, med2],\n                        \"severity\": interaction.split(\"(\")[1].replace(\")\", \"\").strip() if \"(\" in interaction else \"unknown\",\n                        \"description\": interaction.split(\"(\")[0].strip() if \"(\" in interaction else interaction\n                    })\n        \n        # Find class-based interactions\n        class_based_interactions = []\n        for i, med1 in enumerate(medications):\n            med1_lower = med1.lower().split()[0]\n            med1_classes = drug_classifications.get(med1_lower, [])\n            \n            for med2 in medications[i+1:]:\n                med2_lower = med2.lower().split()[0]\n                med2_classes = drug_classifications.get(med2_lower, [])\n                \n                for c1 in med1_classes:\n                    for c2 in med2_classes:\n                        # Check both orderings of the classes\n                        class_interaction = class_interactions.get((c1, c2)) or class_interactions.get((c2, c1))\n                        if class_interaction:\n                            class_based_interactions.append({\n                                \"medications\": [med1, med2],\n                                \"drug_classes\": [c1, c2],\n                                \"description\": class_interaction\n                            })\n        \n        # Create comprehensive results\n        result = {\n            \"medications_analyzed\": medications,\n            \"direct_interactions\": direct_interactions,\n            \"class_based_interactions\": class_based_interactions,\n            \"allergy_contraindications\": allergy_contraindications,\n            \"disclaimer\": (\n                \"MEDICAL DISCLAIMER: This analysis is based on a simplified interaction database \"\n                \"and is not exhaustive. Always consult with a healthcare provider or pharmacist \"\n                \"for a complete medication interaction analysis.\"\n            )\n        }\n        \n        import json\n        return StringToolOutput(json.dumps(result, indent=2))\n",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:30:51.654536",
    "last_updated": "2025-03-21T18:30:51.654545",
    "tags": [
      "medical",
      "medication",
      "interaction",
      "healthcare"
    ],
    "metadata": {},
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "medication_interaction_check",
        "name": "Medication Interaction Check",
        "description": "Checks for potential interactions between medications and allergies",
        "context": {
          "required_fields": [
            "medications",
            "allergies"
          ],
          "produced_fields": [
            "interactions",
            "contraindications",
            "warnings"
          ]
        }
      }
    ]
  },
  {
    "id": "5fc260ae-68c7-4cb9-8669-e199c509918b",
    "name": "Data Extraction Agent",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Implement a system using NLP techniques to extract and structure data from unstructured medical records.",
    "code_snippet": "def extract_and_structure_data(raw_medical_records):\n    # NLP and data structuring logic here\n    return structured_patient_data",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:33:40.807773",
    "last_updated": "2025-03-21T18:33:40.807778",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-21T18:33:35.359160",
        "requirements_summary": "NLP and data structuring logic to extract and structure data from unstructured medical records."
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "extract_patient_information",
        "name": "Extract Patient Information",
        "description": "Extracts patient information such as name, age, and contact details from unstructured medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "patient_name",
            "patient_age",
            "patient_contact"
          ]
        }
      },
      {
        "id": "extract_medical_history",
        "name": "Extract Medical History",
        "description": "Identifies and extracts the patient's medical history, including past diagnoses and treatments.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "medical_history"
          ]
        }
      },
      {
        "id": "extract_medication_information",
        "name": "Extract Medication Information",
        "description": "Extracts details about current and past medications prescribed to the patient.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "current_medications",
            "past_medications"
          ]
        }
      },
      {
        "id": "extract_lab_results",
        "name": "Extract Lab Results",
        "description": "Extracts laboratory test results from the medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "lab_results"
          ]
        }
      },
      {
        "id": "extract_doctor_notes",
        "name": "Extract Doctor Notes",
        "description": "Extracts notes and observations made by doctors during consultations.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "doctor_notes"
          ]
        }
      },
      {
        "id": "structure_extracted_data",
        "name": "Structure Extracted Data",
        "description": "Structures the extracted data into a standardized format for further analysis or storage.",
        "context": {
          "required_fields": [
            "extracted_data"
          ],
          "produced_fields": [
            "structured_patient_data"
          ]
        }
      }
    ]
  },
  {
    "id": "cc404dd4-b908-4248-9210-4778e553de05",
    "name": "Symptom Analysis Agent",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Use a symptom analysis engine to map symptoms to potential conditions using a medical knowledge base.",
    "code_snippet": "def analyze_symptoms(structured_patient_data):\n    # Symptom analysis logic here\n    return identified_conditions",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:33:48.995075",
    "last_updated": "2025-03-21T18:33:48.995081",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-21T18:33:46.817512",
        "requirements_summary": "Symptom analysis logic to map symptoms to potential conditions using a medical knowledge base."
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "symptom_mapping",
        "name": "Symptom Mapping",
        "description": "Maps patient symptoms to potential medical conditions using a medical knowledge base.",
        "context": {
          "required_fields": [
            "structured_patient_data"
          ],
          "produced_fields": [
            "identified_conditions"
          ]
        }
      },
      {
        "id": "condition_identification",
        "name": "Condition Identification",
        "description": "Identifies potential medical conditions based on the analysis of provided symptoms.",
        "context": {
          "required_fields": [
            "structured_patient_data"
          ],
          "produced_fields": [
            "identified_conditions"
          ]
        }
      }
    ]
  },
  {
    "id": "9ff5c4c2-5fb8-4b00-b8b1-dc630e394bbc",
    "name": "Medication Interaction Agent",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Integrate a drug interaction checker to evaluate current medications and suggest necessary adjustments.",
    "code_snippet": "def check_medication_interactions(structured_patient_data):\n    # Medication interaction checking logic here\n    return interaction_warnings, medication_adjustments",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:33:59.829391",
    "last_updated": "2025-03-21T18:33:59.829400",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-21T18:33:57.292212",
        "requirements_summary": "Medication interaction checking logic to evaluate current medications and suggest necessary adjus..."
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "check_interactions",
        "name": "Check Medication Interactions",
        "description": "Evaluates the current medications a patient is taking to identify any potential interactions.",
        "context": {
          "required_fields": [
            "structured_patient_data"
          ],
          "produced_fields": [
            "interaction_warnings"
          ]
        }
      },
      {
        "id": "suggest_adjustments",
        "name": "Suggest Medication Adjustments",
        "description": "Provides recommendations for adjusting medications based on identified interactions.",
        "context": {
          "required_fields": [
            "structured_patient_data"
          ],
          "produced_fields": [
            "medication_adjustments"
          ]
        }
      }
    ]
  },
  {
    "id": "707a5103-69b6-4646-9244-ee89253d1bde",
    "name": "Treatment Recommendation Agent",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Create a recommendation system that uses patient history and identified conditions to suggest treatments.",
    "code_snippet": "def recommend_treatments(identified_conditions, structured_patient_data):\n    # Treatment recommendation logic here\n    return treatment_recommendations",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:34:09.637103",
    "last_updated": "2025-03-21T18:34:09.637108",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-21T18:34:08.148843",
        "requirements_summary": "Treatment recommendation logic to use patient history and identified conditions to suggest treatm..."
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "treatment_recommendation",
        "name": "Treatment Recommendation",
        "description": "Generates a list of recommended treatments based on the patient's medical history and identified conditions.",
        "context": {
          "required_fields": [
            "identified_conditions",
            "structured_patient_data"
          ],
          "produced_fields": [
            "treatment_recommendations"
          ]
        }
      }
    ]
  },
  {
    "id": "8c1c4307-6526-47ea-a8d2-b23b2ba5b162",
    "name": "Medical Disclaimer Agent",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Develop a system to generate disclaimers and alerts based on treatment recommendations and potential risks.",
    "code_snippet": "def generate_disclaimers(treatment_recommendations):\n    # Disclaimer generation logic here\n    return disclaimers, consultation_alerts",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:34:19.330526",
    "last_updated": "2025-03-21T18:34:19.330532",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-21T18:34:17.889270",
        "requirements_summary": "Disclaimer generation logic to generate disclaimers and alerts based on treatment recommendations..."
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "generate_disclaimers",
        "name": "Generate Disclaimers",
        "description": "Generates disclaimers based on provided treatment recommendations to inform users of potential risks and necessary precautions.",
        "context": {
          "required_fields": [
            "treatment_recommendations"
          ],
          "produced_fields": [
            "disclaimers",
            "consultation_alerts"
          ]
        }
      }
    ]
  },
  {
    "id": "a548776f-3d45-4067-9b47-631fc350081b",
    "name": "Emergency Detection Agent",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Implement a real-time monitoring system to detect symptoms indicative of emergency conditions.",
    "code_snippet": "def detect_emergencies(structured_patient_data):\n    # Emergency detection logic here\n    return emergency_alerts",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:34:32.318676",
    "last_updated": "2025-03-21T18:34:32.318680",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "requirements",
        "timestamp": "2025-03-21T18:34:30.493537",
        "requirements_summary": "Emergency detection logic to detect symptoms indicative of emergency conditions."
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "real_time_monitoring",
        "name": "Real-Time Monitoring",
        "description": "Continuously monitors structured patient data to identify potential emergency conditions.",
        "context": {
          "required_fields": [
            "structured_patient_data"
          ],
          "produced_fields": [
            "emergency_alerts"
          ]
        }
      },
      {
        "id": "emergency_detection",
        "name": "Emergency Detection",
        "description": "Analyzes patient data to detect symptoms that may indicate an emergency situation, triggering alerts if necessary.",
        "context": {
          "required_fields": [
            "structured_patient_data"
          ],
          "produced_fields": [
            "emergency_alerts"
          ]
        }
      }
    ]
  },
  {
    "id": "62940a21-34ed-41b8-9eb8-d6956ee5beaf",
    "name": "Medical Records Parser",
    "record_type": "AGENT",
    "domain": "general",
    "description": "Implement a parser that uses machine learning models to identify and extract relevant data fields from medical records.",
    "code_snippet": "# Implement a parser that uses machine learning models to identify and extract relevant data fields from medical records.\ndef parse_medical_records(raw_medical_records):\n    # Parsing logic here\n    return structured_patient_data",
    "version": "1.0.0",
    "usage_count": 0,
    "success_count": 0,
    "fail_count": 0,
    "status": "active",
    "created_at": "2025-03-21T18:35:54.455837",
    "last_updated": "2025-03-21T18:35:54.455846",
    "tags": [
      "general",
      "agent"
    ],
    "metadata": {
      "framework": "beeai",
      "creation_strategy": {
        "method": "direct_code",
        "timestamp": "2025-03-21T18:35:48.921255",
        "requirements_summary": null
      }
    },
    "performance_metrics": {
      "total_executions": 0,
      "successful_executions": 0,
      "average_execution_time": 0.0,
      "capabilities": {},
      "domains": {},
      "last_execution": null
    },
    "capabilities": [
      {
        "id": "extract_patient_identifiers",
        "name": "Extract Patient Identifiers",
        "description": "Identifies and extracts patient identifiers such as name, date of birth, and patient ID from medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "patient_name",
            "date_of_birth",
            "patient_id"
          ]
        }
      },
      {
        "id": "extract_medical_history",
        "name": "Extract Medical History",
        "description": "Extracts detailed medical history information including past diagnoses, treatments, and surgeries from medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "diagnoses",
            "treatments",
            "surgeries"
          ]
        }
      },
      {
        "id": "extract_medication_information",
        "name": "Extract Medication Information",
        "description": "Identifies and extracts information about current and past medications prescribed to the patient.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "current_medications",
            "past_medications"
          ]
        }
      },
      {
        "id": "extract_lab_results",
        "name": "Extract Lab Results",
        "description": "Extracts laboratory test results and related data from medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "lab_test_names",
            "lab_test_results",
            "test_dates"
          ]
        }
      },
      {
        "id": "extract_allergies",
        "name": "Extract Allergies",
        "description": "Identifies and extracts information about patient allergies from medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "allergies"
          ]
        }
      },
      {
        "id": "extract_vital_signs",
        "name": "Extract Vital Signs",
        "description": "Extracts vital signs data such as blood pressure, heart rate, and temperature from medical records.",
        "context": {
          "required_fields": [
            "raw_medical_records"
          ],
          "produced_fields": [
            "blood_pressure",
            "heart_rate",
            "temperature"
          ]
        }
      }
    ]
  }
]